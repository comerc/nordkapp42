schema {
  subscription: subscription_root
}
scalar timestamptz
"""
columns and relationships of "message"
"""
type Message {
  createdAt: timestamptz!
  id: Int!
  isRead: Boolean
  "source on2on message"
  messageId: Int
  roomId: Int!
  text: String!
  updatedAt: timestamptz!
}
type subscription_root {
  """
  fetch data from the table: "message"
  """
  selectMessage(
    "distinct select on columns"
    distinctOn: [MessageSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [MessageOrderBy!],
    "filter the rows returned"
    where: MessageBoolExp
  ): [Message!]!
  """
  fetch data from the table in a streaming manner: "message"
  """
  selectMessageStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [MessageStreamCursorInput]!,
    "filter the rows returned"
    where: MessageBoolExp
  ): [Message!]!
}
"ordering argument of a cursor"
enum CursorOrdering {
  "ascending ordering of the cursor"
  ASC
  "descending ordering of the cursor"
  DESC
}
"""
unique or primary key constraints on table "message"
"""
enum MessageConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_pkey
}
"""
select columns of table "message"
"""
enum MessageSelectColumn {
  "column name"
  createdAt
  "column name"
  id
  "column name"
  isRead
  "column name"
  messageId
  "column name"
  roomId
  "column name"
  text
  "column name"
  updatedAt
}
"column ordering options"
enum OrderBy {
  "in ascending order, nulls last"
  ASC
  "in ascending order, nulls first"
  ASC_NULLS_FIRST
  "in ascending order, nulls last"
  ASC_NULLS_LAST
  "in descending order, nulls first"
  DESC
  "in descending order, nulls first"
  DESC_NULLS_FIRST
  "in descending order, nulls last"
  DESC_NULLS_LAST
}
"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}
"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}
"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input MessageBoolExp {
  _and: [MessageBoolExp!]
  _not: MessageBoolExp
  _or: [MessageBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: IntComparisonExp
  isRead: BooleanComparisonExp
  messageId: IntComparisonExp
  roomId: IntComparisonExp
  text: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
Ordering options when selecting data from "message".
"""
input MessageOrderBy {
  createdAt: OrderBy
  id: OrderBy
  isRead: OrderBy
  messageId: OrderBy
  roomId: OrderBy
  text: OrderBy
  updatedAt: OrderBy
}
"""
Streaming cursor of the table "message"
"""
input MessageStreamCursorInput {
  "Stream column input with initial value"
  initialValue: MessageStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input MessageStreamCursorValueInput {
  createdAt: timestamptz
  id: Int
  isRead: Boolean
  "source on2on message"
  messageId: Int
  roomId: Int
  text: String
  updatedAt: timestamptz
}
"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _isNull: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}
"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
# "whether this query should be cached (Hasura Cloud only)"
# directive @cached(
#     "measured in seconds"
#     ttl: Int! = 60,
#     "refresh the cache entry"
#     refresh: Boolean! = false
#   ) on QUERY

